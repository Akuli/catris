<!DOCTYPE html>
<html>
  <head>
    <script>
document.addEventListener("DOMContentLoaded", () => {
  const COLORS = {
    // taken from mate-terminal with a color picker program
    '1;0': {fg: '#FFFFFF', bg: '#000000'},  // reset all colors
    '1;30': {fg: '#555753'},
    '1;31': {fg: '#EF2929'},
    '1;32': {fg: '#8AE234'},
    '1;33': {fg: '#FCE94F'},
    '1;34': {fg: '#729FCF'},
    '1;35': {fg: '#AD7FA8'},
    '1;36': {fg: '#34E2E2'},
    '1;40': {bg: '#2E3436'},
    '1;41': {bg: '#CC0000'},
    '1;42': {bg: '#4E9A06'},
    '1;43': {bg: '#C4A000'},
    '1;44': {bg: '#3465A4'},
    '1;45': {bg: '#75507B'},
    '1;46': {bg: '#06989A'},
    '1;47': {bg: '#D3D7CF'},

    // TODO: duplicates of 1;3x and 1;4x colors, stop using these
    '1;90': {fg: '#555753'},
    '1;91': {fg: '#EF2929'},
    '1;92': {fg: '#8AE234'},
    '1;93': {fg: '#FCE94F'},
    '1;94': {fg: '#729FCF'},
    '1;95': {fg: '#AD7FA8'},
    '1;96': {fg: '#34E2E2'},
    '1;100': {bg: '#2E3436'},
    '1;101': {bg: '#CC0000'},
    '1;102': {bg: '#4E9A06'},
    '1;103': {bg: '#C4A000'},
    '1;104': {bg: '#3465A4'},
    '1;105': {bg: '#75507B'},
    '1;106': {bg: '#06989A'},
    '1;107': {bg: '#D3D7CF'},
  };

  WIDTH = 80;
  HEIGHT = 33;  // enough for ring game

  const terminal = new class {
    constructor() {
      this._pre = document.getElementById("terminal");
      this._pre.style.width = WIDTH + "ch";
      this._pre.style.height = HEIGHT + "em";
      this.clear();

      this._inputBuffer = "";

      this.fgColor = COLORS['1;0'].fg;
      this.bgColor = COLORS['1;0'].bg;
    }

    clear() {
      this._pre.innerHTML = "<span></span>";
      this._pre.querySelector("span").textContent = (" ".repeat(WIDTH) + "\n").repeat(HEIGHT);
      this._cursorPos = 0;  // index into the text as a string including \n chars
    }

    getCursorY() {
      return Math.floor(this._cursorPos / (WIDTH + 1));
    }

    getCursorX() {
      return this._cursorPos % (WIDTH + 1);
    }

    moveCursor(x, y) {
      this._cursorPos = y*(WIDTH + 1) + x;
    }

    moveCursorToStartOfLine() {
      const lineStartToCursor = this._cursorPos % (WIDTH + 1);
      this._cursorPos -= lineStartToCursor;
    }

    moveCursorDown() {
      this._cursorPos += WIDTH + 1;
    }

    // FIXME: cursor doesn't show currently
    showCursor() {
      this._pre.classList.add("cursor-is-showing");
    }

    hideCursor() {
      this._pre.classList.remove("cursor-is-showing");
    }

    _applyStyle(span) {
      /*
      span.style.color = this.fgColor;
      span.style.backgroundColor = this.bgColor;
      */
    }

    // FIXME: may need merging spans
    _deleteText(delStart, delEnd) {
      if (delStart >= delEnd) {
        // TODO: can this happen?
        return;
      }

      const spans = [...this._pre.children];
      let spanStart = 0;
      for (const span of spans) {
        const spanEnd = spanStart + span.textContent.length;

        const overlapStart = Math.max(spanStart, delStart);
        const overlapEnd = Math.min(spanEnd, delEnd);
        if (overlapStart < overlapEnd) {
          // Delete overlapping part
          // TODO: watch out for empty spans?
          const relativeOverlapStart = overlapStart - spanStart;
          const relativeOverlapEnd = overlapEnd - spanStart;
          const t = span.textContent;
          span.textContent = t.slice(0, relativeOverlapStart) + t.slice(relativeOverlapEnd);
        }

        spanStart = spanEnd;
      }
    }

    // FIXME: may need merging spans
    _insertText(index, text) {
      if (text === "") {
        return;
      }

      const newSpan = document.createElement("span");
      newSpan.textContent = text;
      this._applyStyle(newSpan);

      const spans = [...this._pre.children];
      let spanStart = 0;
      for (const span of spans) {
        if (index === spanStart) {
          // New span goes just before start of an existing span
          this._pre.insertBefore(newSpan, span);
          return;
        }

        const spanEnd = spanStart + span.textContent.length;
        if (spanStart < index && index < spanEnd) {
          // Split span into two, add in middle
          const relativeIndex = index - spanStart;
          const fullText = span.textContent;
          const leftSide = span.cloneNode();
          leftSide.textContent = fullText.slice(0, relativeIndex);
          span.textContent = fullText.slice(relativeIndex);
          this._pre.insertBefore(leftSide, span);
          this._pre.insertBefore(newSpan, span);
          return;
        }

        spanStart = spanEnd;
      }

      // New span is not at the start of any span and not inside any span.
      // It must be after all the spans.
      this._div.appendChild(span);
    }

    _replaceText(startIndex, text) {
      this._deleteText(startIndex, startIndex + text.length);
      this._insertText(startIndex, text);
    }

    clearFromCursorToEndOfScreen() {
      const end = (WIDTH + 1)*HEIGHT;
      this._replaceText(this._cursorPos, " ".repeat(end - this._cursorPos));
    }

    clearFromCursorToEndOfLine() {
      const lineStartToCursor = this._cursorPos % (WIDTH + 1)
      const lineStart = this._cursorPos - lineStartToCursor;
      const nextLineStart = lineStart + WIDTH + 1;
      const end = (WIDTH + 1)*HEIGHT;
      console.log("cursor pos", this._cursorPos);
      console.log("lineStartToCursor", lineStartToCursor);
      console.log("lineStart", lineStart);
      console.log("nextLineStart", nextLineStart);
      console.log("end", end);
      this._replaceText(this._cursorPos, " ".repeat(nextLineStart - this._cursorPos));
    }

    addText(text) {
      const end = (WIDTH + 1)*HEIGHT;
      const howMuchFits = end - this._cursorPos;
      const truncatedText = text.slice(0, howMuchFits);
      this._replaceText(this._cursorPos, truncatedText);
      this._cursorPos += truncatedText.length;
    }

    addTextWithEscapeSequences(text) {
      this._inputBuffer += text;

      while (this._inputBuffer !== "") {
        const specialCharMatch = /\x1b|\r|\n/.exec(this._inputBuffer);
        if (specialCharMatch !== null && specialCharMatch.index === 0) {
          if (specialCharMatch[0] === '\r') {
            this.moveCursorToStartOfLine();
            this._inputBuffer = this._inputBuffer.slice(1);
          } else if (specialCharMatch[0] === '\n') {
            this.moveCursorDown();
            this._inputBuffer = this._inputBuffer.slice(1);
          } else if (specialCharMatch[0] === '\x1b') {
            // Start of ANSI code
            if (this._inputBuffer.length < 2) {
              break;  // need more data
            }
            if (this._inputBuffer.slice(0, 2) != "\x1b[") {
              // server sent something weird, this is how every ansi sequence starts
              this._inputBuffer = this._inputBuffer.slice(1);
              continue;
            }

            const letterMatch = /[A-Za-z]/.exec(this._inputBuffer);
            if (letterMatch === null) {
              if (canBeIncompleteAnsiCode) {
                break;  // need more data
              } else {
                // server sent invalid ansi sequences???
                this._inputBuffer = this._inputBuffer.slice(1);
                continue;
              }
            }
            const letter = letterMatch[0];
            const contents = this._inputBuffer.slice(2, letterMatch.index);
            this._inputBuffer = this._inputBuffer.slice(letterMatch.index + 1);

            if (letter === 'J' && contents === '2') {
              this.clear();
            } else if (letter === 'J' && contents === '0') {
              this.clearFromCursorToEndOfScreen();
            } else if (letter === 'K' && contents === '0') {
              console.log("Clear from cursor to end of line");
              this.clearFromCursorToEndOfLine();
            } else if (letter === 'h' && contents === '?25') {
              this.showCursor();
            } else if (letter === 'l' && contents === '?25') {
              this.hideCursor();
            } else if (letter === 'H') {
              const [line, column] = contents.split(';').map(x => +x);
              console.log("Move cursor", contents);
              this.moveCursor(column-1, line-1);
            } else if (letter === 'm' && contents.startsWith("1;")) {
              const colorInfo = COLORS[contents];
              if (colorInfo === undefined) {
                console.warn("unknown color " + contents);
              } else {
                if (colorInfo.fg) this.fgColor = colorInfo.fg;
                if (colorInfo.bg) this.bgColor = colorInfo.bg;
              }
            } else {
              console.warn("Unknown ANSI escape sequence: " + contents + letter);
            }
          } else {
            throw new Error("wut");
          }
        } else {
          // Normal text, aka 1 or more non-special chars
          let normalText;
          if (specialCharMatch === null) {
            normalText = this._inputBuffer;
          } else {
            normalText = this._inputBuffer.slice(0, specialCharMatch.index);
          }
          this._inputBuffer = this._inputBuffer.slice(normalText.length);
          console.log("Text", normalText);
          this.addText(normalText);
        }
      }
    }
  };

  const ws = new WebSocket(`ws://${window.location.hostname}:54321`);

  document.onkeydown = event => {
    if (event.ctrlKey || event.altKey || ws.readyState !== WebSocket.OPEN) {
      return;
    }

    let textToSend;
    if (event.key.length === 1) {
      textToSend = event.key;
    } else if (event.key === "ArrowUp") {
      textToSend = "\x1b[A";
    } else if (event.key === "ArrowDown") {
      textToSend = "\x1b[B";
    } else if (event.key === "ArrowRight") {
      textToSend = "\x1b[C";
    } else if (event.key === "ArrowLeft") {
      textToSend = "\x1b[D";
    } else if (event.key === "Backspace") {
      textToSend = "\x7f";
    } else if (event.key === "Enter") {
      textToSend = "\r";
    } else {
      console.log("Unrecognized key:", event.key);
      return;
    }

    const utf8 = new TextEncoder().encode(textToSend);
    ws.send(utf8);

    event.preventDefault();
  };

  // For some reason, the .text() method on Blob is asynchronous.
  // We need to make sure they run in the correct order, and not at the same time.
  let receivedBlobs = [];
  let blobTask = null;

  async function handleBlobs() {
    while (receivedBlobs.length !== 0) {
      let a = performance.now();
      const blobs = receivedBlobs;
      receivedBlobs = [];
      const texts = await Promise.all(blobs.map(b => b.text()));
      let b = performance.now();
      const blobTime = b-a;
      console.log(`blobbing took ${Math.round(blobTime)}ms with ${blobs.length} blobs`);

      if (ws.readyState === WebSocket.OPEN) {
        let a = performance.now();
        terminal.addTextWithEscapeSequences(texts.join(""));
        let b = performance.now();
        const addTextTime = b-a;

        console.log(`addTextWithEscapeSequences took ${Math.round(addTextTime)}ms with ${texts.join("").length} chars`);
      }
    }
  }

  ws.onmessage = (msg) => {
    receivedBlobs.push(msg.data);
    if (blobTask === null) {
      blobTask = handleBlobs();
      blobTask.then(() => blobTask=null);
    }
  };
  // no need for onerror(), because onclose() will run on errors too
  ws.onclose = () => {
    document.body.innerHTML = "Connection closed.";
  };
});
    </script>
    <style>
body {
  background-color: #333;
  color: white;
}

#terminal {
  color: white;
  background-color: black;
  padding: 0.2em;
  border-radius: 0.5em;
  text-align: left;
  line-height: 100%;
}

#terminal.cursor-is-showing > .cursor {
  animation: blinking_cursor 1s step-start infinite;
}

/* https://stackoverflow.com/a/48320520 */
@keyframes blinking_cursor {
  50% {
    color: black;
    background-color: white;
  }
}
    </style>
  </head>
  <body>
    <pre id="terminal"><span></span></div>
  </body>
</html>
